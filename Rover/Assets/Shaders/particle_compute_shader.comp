#version 460

struct Particle
{
    vec2 position;
    vec2 velocity;
    vec4 color;

    float time_elapsed;
};

struct ParticleParameters 
{
    // Color Gradient
    vec4 color_1;
    vec4 color_2;

    // Shape
    float scale;

    // Emission
    float life_time; // particles lifetiem in seconds;
    float dt; // delta time this frame in seconds
    float emission_rate;
    uint live_particles;
    uint repeating; // set to 1 if repeating

    // Buffer offsets
    uint buffer_offset; // Offset into global particle buffer
    uint buffer_index; // Offset into global particle buffer array
};

layout(std140, set = 0, binding = 0) readonly buffer ParticleParametersUBO {
    ParticleParameters parameters[];
} _particle_parameters_array;

layout(std140, set = 0, binding = 1) readonly buffer ParticlesIn{
    Particle particles[];
} _particles_in;

layout(std140, set = 0, binding = 2) buffer ParticlesOut{
    Particle particles[];
} _particles_out;

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout( push_constant ) uniform ParticleSystemPushConstant{
	uint index;             // index into particle parameters buffer
    float world_space;      // 1 if world_space : 0 if local
    float new_particles;    // 1 if new_particle : 0 if no new particles
    float reset;            // 1 if reset : 0 if no reset

    mat4 emission_transform;    // emission point (used if world space particle system)
} _particle_push_constant;

vec2 gravity = vec2(0.0f, -9.8f);
void main()
{
    ParticleParameters particle_parameters = _particle_parameters_array.parameters[_particle_push_constant.index];

    uint local_index = gl_GlobalInvocationID.x;
    uint global_index = gl_GlobalInvocationID.x + particle_parameters.buffer_index;

    // Check if particle is live
    if(local_index >= particle_parameters.live_particles) 
    {
        return;
    }

    Particle particle_in = _particles_in.particles[global_index];

    // Flags
    float new_particle = 1.0f - clamp(ceil(_particles_out.particles[global_index].time_elapsed), 0.0f, 1.0f);
    float world_space_particle = _particle_push_constant.world_space;

    // Increment elapsed_time by dt
    _particles_out.particles[global_index].time_elapsed += particle_parameters.dt;

    // Gravity
    _particles_out.particles[global_index].position += 0.5f * gravity * pow(particle_parameters.dt, 2);

    // Velocity
    _particles_out.particles[global_index].position += particle_in.velocity * particle_parameters.dt;


    // [IF] (world space particle && new particle) { add offset with emission point}
    vec4 world_position = _particle_push_constant.emission_transform * vec4(_particles_out.particles[global_index].position, 1.0f, 1.0f);
    _particles_out.particles[global_index].position *= 1.0f - (world_space_particle * new_particle);
    _particles_out.particles[global_index].position += world_position.xy * (world_space_particle * new_particle);

    // Color (Self resetting because it is interpolated)
    float time_elapsed_normalized = _particles_out.particles[global_index].time_elapsed / particle_parameters.life_time;
    _particles_out.particles[global_index].color =  particle_parameters.color_1 * (1.0f - time_elapsed_normalized) + particle_parameters.color_2 * time_elapsed_normalized;

    // TODO: Add Rotation over time
    // TODO: Add Stop (Stop emitting particles)

    // No lifetime reset if not repeating
    if(particle_parameters.repeating < 1)
    {
        return;
    }

    float time_elapsed = _particles_out.particles[global_index].time_elapsed;
    if(time_elapsed >= particle_parameters.life_time)
    {
        // TODO: Fix gravity reset
        // _particles_out.particles[global_index].position -= 0.5f * (gravity * pow(time_elapsed, 2));

        // Reset position (If not repeating)
        // _particles_out.particles[global_index].position -= particle_in.velocity * time_elapsed;
        _particles_out.particles[global_index].position *= 0.0f;
        // _particles_out.particles[global_index].position = normalize(_particles_out.particles[global_index].position);

        // Reset time (If not repeating)
        _particles_out.particles[global_index].time_elapsed = 0.0f;
    }
}
