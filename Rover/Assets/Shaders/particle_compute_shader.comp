#version 460

struct Particle
{
    vec2 position;
    vec2 velocity;
    vec4 color;

    float time_elapsed;
};

struct ParticleParameters 
{
    // Color Gradient
    vec4 color_1;
    vec4 color_2;

    // Shape
    float scale;

    // Emission
    float life_time; // particles lifetiem in seconds;
    float dt; // delta time this frame in seconds
    float emission_rate;
    uint live_particles;
    uint repeating; // set to 1 if repeating

    // Buffer offsets
    uint buffer_offset; // Offset into global particle buffer
    uint buffer_index; // Offset into global particle buffer array
};

layout(std140, set = 0, binding = 0) readonly buffer ParticleParametersUBO {
    ParticleParameters parameters[];
} _particle_parameters_array;

layout(std140, set = 0, binding = 1) readonly buffer ParticlesIn{
    Particle particles[];
} _particles_in;

layout(std140, set = 0, binding = 2) buffer ParticlesOut{
    Particle particles[];
} _particles_out;

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout( push_constant ) uniform ParticleSystemPushConstant{
	uint index;     // index into particle parameters buffer
} _particle_push_constant;

vec2 gravity = vec2(0, -9.8f);
void main()
{
    ParticleParameters particle_parameters = _particle_parameters_array.parameters[_particle_push_constant.index];

    uint local_index = gl_GlobalInvocationID.x;
    uint global_index = gl_GlobalInvocationID.x + particle_parameters.buffer_index;

    // Check if particle is live
    if(local_index >= particle_parameters.live_particles) 
    {
        return;
    }

    Particle particle_in = _particles_in.particles[global_index];

    // Increment elapsed_time by dt
    _particles_out.particles[global_index].time_elapsed += particle_parameters.dt;

    // Gravity
    _particles_out.particles[global_index].position += 0.5f * gravity * pow(particle_parameters.dt, 2);

    // Velocity
    _particles_out.particles[global_index].position += particle_in.velocity * particle_parameters.dt;

    // Color (Self resetting because it is interpolated)
    float time_elapsed_normalized = _particles_out.particles[global_index].time_elapsed / particle_parameters.life_time;
    _particles_out.particles[global_index].color =  particle_parameters.color_1 * (1.0f - time_elapsed_normalized) + particle_parameters.color_2 * time_elapsed_normalized;

    // TODO: Add Rotation over time
    // TODO: Add Stop (Stop emitting particles)

    // No lifetime reset if not repeating
    if(particle_parameters.repeating < 1)
    {
        return;
    }

    float time_elapsed = _particles_out.particles[global_index].time_elapsed;
    if(time_elapsed >= particle_parameters.life_time)
    {
        // Reset position (If not repeating)
        _particles_out.particles[global_index].position -= particle_in.velocity * time_elapsed;
        //_particles_out.particles[global_index].position -= 0.5f * gravity * pow(time_elapsed, 2);

        // Reset time (If not repeating)
        _particles_out.particles[global_index].time_elapsed = 0.0f;
    }

    // TODO: Optmize Compute Shader
    // Reset on lifetime reached
    // float life_time_elapsed = min(floor(_particles_out.particles[global_index].time_elapsed / particle_parameters.life_time), 1.0f);
    //     // Reset position (If not repeating)
    //     _particles_out.particles[global_index].position *= (1 - life_time_elapsed);

    //     // Reset time (If not repeating)
    //     _particles_out.particles[global_index].time_elapsed *= (1 - life_time_elapsed);

    // Manual reset
    // _particles_out.particles[global_index].position *= (1 - particle_parameters.reset);
    // _particles_out.particles[global_index].time_elapsed *= (1 - particle_parameters.reset);
}
